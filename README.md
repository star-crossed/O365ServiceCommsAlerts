# O365ServiceCommsAlerts
This is a Microsoft Flow that posts cards of Office 365 Service Communications in a Microsoft Teams channel.

## How to Use This

You can find a zipped release version of these files in the Releases tab above. The zip file should import as-is into your Flow tenant with no errors. However, there are settings which will need to be changed to reflect your environment. These are:

- Get Messages: The URI field needs to have the tenant domain replaced.
- Get Messages: The Tenant field needs to have the tenant domain replaced.
- Get Messages: The Client ID field needs to have the client ID replaced.
- Get Messages: The Secret field needs to have the client secret replaced.
- Post a card in Alerts channel of IT Department team: The URI field needs to have the Incoming Webhook URL replaced.
- Post a card in Alerts channel of IT Department team: The Flow may not save because raw @ symbols appear in the Body field. To save, you may need to escape them with another @ symbol (e.g. @@type) before saving.

You will need to have an Incoming Webhook connector added to the channel in the team that you want to receive the alerts. You will also need to register an app in Azure AD to provide access to the Office 365 Service Communications API. Details on how to setup both of these items can be found in later sections of this page.

**Please submit an issue if you encounter any customizations or errors not described above during the import process.**

## How to Recreate The Flow

If you wish to recreate this Flow in your tenant rather than import it, you may do so by following these instructions. Begin by creating a blank Flow and then add a Recurrence trigger. This trigger dictates how often the messages potentially may be posted. In this example, it will post once daily (assuming new messages exist.)

![Recurrence](https://imgur.com/JcIrINn.png)

Next, you will add an Http action. The action should be configured as seen below. The following details should be modified to reflect your environment:

- Get Messages: The URI field needs to have the tenant domain replaced.
- Get Messages: The Tenant field needs to have the tenant domain replaced.
- Get Messages: The Client ID field needs to have the client ID replaced.
- Get Messages: The Secret field needs to have the client secret replaced.

The expression shown is to calculate today's date minus 1 day. This is used to filter and return only messages that were modified up to a day prior to the time when this Flow runs. If you opt for a different recurrence pattern, you will likely need to change this filter and expression to reflect what you need. A link to the Workflow Definition Language can be found at the end of this page to assist with editing the expression.

The authentication information can be obtained when registering an app in Azure AD. Information on what's required by the Office 365 Serivce Communications API can be found in the References section at the end of this page. Instructions on how to appropriate register an app for this Flow can be found in a later section of this page.

![Get Messages](https://imgur.com/eFxVjBO.png)

Now add a Parse Json action. The Content field should be set to use the Body property in the response from the Get Messages action. The schema can be generated by using a sample from the Office 365 Service Communications API documentation. I have included the resulting schema here to allow you to cut-and-paste it if you choose. The API documentation can be found in the References section at the end of this page.

`{
    "type": "object",
    "properties": {
        "@@odata.context": {
            "type": "string"
        },
        "value": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "@@odata.type": {
                        "type": "string"
                    },
                    "AffectedWorkloadDisplayNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "AffectedWorkloadNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "Status": {
                        "type": "string"
                    },
                    "Workload": {},
                    "WorkloadDisplayName": {},
                    "ActionType": {
                        "type": "string"
                    },
                    "AffectedTenantCount": {
                        "type": "number"
                    },
                    "AffectedUserCount": {},
                    "Classification": {
                        "type": "string"
                    },
                    "EndTime": {
                        "type": "string"
                    },
                    "Feature": {},
                    "FeatureDisplayName": {},
                    "Id": {
                        "type": "string"
                    },
                    "ImpactDescription": {},
                    "LastUpdatedTime": {
                        "type": "string"
                    },
                    "MessageType": {
                        "type": "string"
                    },
                    "Messages": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "MessageText": {
                                    "type": "string"
                                },
                                "PublishedTime": {
                                    "type": "string"
                                }
                            },
                            "required": [
                                "MessageText",
                                "PublishedTime"
                            ]
                        }
                    },
                    "PostIncidentDocumentUrl": {},
                    "Severity": {
                        "type": "string"
                    },
                    "StartTime": {
                        "type": "string"
                    },
                    "Title": {
                        "type": "string"
                    },
                    "ActionRequiredByDate": {},
                    "AnnouncementId": {
                        "type": "number"
                    },
                    "Category": {
                        "type": "string"
                    },
                    "ExternalLink": {
                        "type": "string"
                    },
                    "IsDismissed": {
                        "type": "boolean"
                    },
                    "IsRead": {
                        "type": "boolean"
                    },
                    "IsMajorChange": {
                        "type": "boolean"
                    },
                    "PreviewDuration": {},
                    "AppliesTo": {},
                    "MilestoneDate": {
                        "type": "string"
                    },
                    "Milestone": {
                        "type": "string"
                    },
                    "BlogLink": {
                        "type": "string"
                    },
                    "HelpLink": {
                        "type": "string"
                    },
                    "FlightName": {},
                    "FeatureName": {}
                },
                "required": [
                    "@@odata.type",
                    "AffectedWorkloadDisplayNames",
                    "AffectedWorkloadNames",
                    "Status",
                    "Workload",
                    "WorkloadDisplayName",
                    "ActionType",
                    "AffectedTenantCount",
                    "AffectedUserCount",
                    "Classification",
                    "EndTime",
                    "Feature",
                    "FeatureDisplayName",
                    "Id",
                    "ImpactDescription",
                    "LastUpdatedTime",
                    "MessageType",
                    "Messages",
                    "PostIncidentDocumentUrl",
                    "Severity",
                    "StartTime",
                    "Title",
                    "ActionRequiredByDate",
                    "AnnouncementId",
                    "Category",
                    "ExternalLink",
                    "IsDismissed",
                    "IsRead",
                    "IsMajorChange",
                    "PreviewDuration",
                    "AppliesTo",
                    "MilestoneDate",
                    "Milestone",
                    "BlogLink",
                    "HelpLink",
                    "FlightName",
                    "FeatureName"
                ]
            }
        }
    }
}`

![Parse Messages](https://imgur.com/OtUmRSZ.png)

Insert a condition next. This condition will be used to test whether any messages were retrieved per the filter in Get Messages. It tests if the length of the array of messages is greater than 0, which indicates at least one message was returned. The expression used is:

`length(body('Parse_Messages')?['value'])`

![Are there any messages](https://imgur.com/PDMB4Y1.png)

The No branch of the condition will remain blank. If no messages are returned, we want the Flow to silently exit the Flow. Inside the Yes branch, we will need to add an Apply to Each action. Even if only one message is returned, the data will come in the form of an array. This means we need to use the Apply to Each to ensure that we are processing all returned messages regardless of quantity. The Output field for this action should be configured to use the value property in the response from the Parse Messages action.

![Do this for each message](https://imgur.com/jfo3DGp.png)

Place an Http action inside the Apply to Each action. This action will be responsible for posting the card to our channel in Microsoft Teams. The channel and team are configured as part of the Incoming Webhook setup. Information on that setup can be found in a later section of this page. This action should be configured as seen below. The following fields will need to be customized to reflect your environment:

- Post a card in Alerts channel of IT Department team: The URI field needs to have the Incoming Webhook URL replaced.

The Body field contains the markup used to represent the card posted in Teams. This markup can be customized as you see fit. A link to the documentation on the markup can be found in the References section later in this page. The markup I have used is shown below so that you can cut-and-paste it if you like.

`{
  "@@type": "MessageCard",
  "@@context": "http://schema.org/extensions",
  "text": "@{last(item().Messages).MessageText}",
  "title": "@{items('Do_this_for_each_message')?['Title']}",
  "sections": [
    {
      "facts": [
        {
          "name": "Services Affected",
          "value": "@{join(item().AffectedWorkloadDisplayNames, ', ')}"
        }
      ]
    }
  ],
  "potentialAction": [
    {
      "@@context": "http://schema.org",
      "@@type": "ViewAction",
      "name": "View related article",
      "target": [
        "@{items('Do_this_for_each_message')?['ExternalLink']}"
      ]
    }
  ]
}`

![Post a card in Alerts channel of IT Department team](https://imgur.com/5gfe0D2.png)

Your Flow is now ready to run! You can test it out, but you may find that no card is posted because no new messages fall within the filter criteria. In this case, you may wish to temporarily alter the filter to allow some historical messages to be added to the channel to "seed" it with some initial content. Just be sure to reset the filter to match your desired recurrence schedule when you are finished.

## How to Create the Incoming Webhook URL

## How to Register the App in Azure AD

## References

